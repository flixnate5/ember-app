# 6 CHAPTER 6 Configuring your Ember.js Application

    
    Configuring your App
    Configuring Ember-CLI
    Prototype Extensions
    Handling Deprecations
    URL Types
    Embedded Applications
    Feature Flags
    Optional Features
    Build Targets
    Robots.txt

## Configuring your App
Ember provides a lot of default configurations that help even beginners to build a large-scale application with ease. 
Ember also provides ways to configure those default values to suit our application’s requirements. 

## Build Environments
Build environments are the types of situations we run the application in. 
There are three environments used in any common application:
- development: local Ember server that you run. 
- test: when you run your tests using the Ember tests command.
- production: where you host the application on a server or a file system to be accessed from anywhere. 

`config/environment.js` file. If you open the file in our existing
project, you can see some prefilled values. The file contains
a function that gets an environment variable as a parameter
and returns an ENV object. Through this environment variable
passed to this function, we are able to configure the settings
of your application. A common example would be that we
will want to disable detailed logging in our production
environment as it might make the application inefficient due
to too much logging.


You can see the if conditions in the config/environment.js file as follows:
```ts

if (environment === ‘development’)
{
    …
}
if (environment === ‘production’){
…
}
```

We can use these if conditions to modify the ENV object before returning it for the application to use.

## App Secrets
The environment variable-based configuration is useful for
cases where we need different settings for the local
environment and other settings for hosted environments
(production). But there are certain cases where you have to
specify additional parameters like API URL, some third-party
API keys, and so on. These values cannot be specified in the
environment file because of the following reasons:
You should not hard-code any API keys or credentials
into your code. When you push the code to any third-
party Version Control System (VCS) like GitHub, the
credentials are accessible to anyone with access to the
repository, which is not recommended, as it can lead to
security problems. The ENV object in the environment
file is set as a Meta tag in the HTML file generated by
the build. So placing any credentials in the ENV object
makes it wide open for everyone to see the credentials.


Even with the same build environment - production,
you
might
build
your
staging
and
production
deployments. In these cases, we will have different API
URLs for different deployments. Handling such cases
with if else conditions will be hectic.


To handle these issues, we will need a way that does not
hard-code the credentials in the repository and supply the
values during the build time of the application. The common
way of doing this is through a .env file. A .env file contains a
key-value syntax used to store sensitive details like
passwords, or flags and values that are specific to the
particular build of the application. Here is a sample of a .env
file. You can add this to the root folder of our project:
API_URL=https://api.mydomain.com
SOME_API_KEY=TestAPIKey
To read the .env file into the Node environments object, we
will install an addon named ember-cli-dotenv:
ember install ember-cli-dotenv
Once this addon is installed, it automatically finds the .env
file in the project root directory and adds those values to the
process.env object, which is a global variable injected into
node runtimes to access the environment variables from the
shell. Typically, these application-level variables are passed
through to the APP key of the ENV object. You can update the
APP section of our config/environment.js file as follows:
const ENV = {
APP: {
...process.env
},
}
Once this is injected, you can access the variables from the
.env file anywhere in the application. Since we have entered
our API URL in the .env file, let us see how we can use that
value in our adapters/application.js file. You can update the
adapter file as follows:
import ENV from ‘../config/environment’;
host = ENV.APP.API_URL;
You can do a console.log of the host or the ENV.APP.API_URL
variable to see the value being fetched from the .env file.


When you pass credentials this way to your application, it is
more secure and flexible to configure. There are different
ways to pass your secrets to the build using the process.env.


It also depends on the CI/CD system you use. For example,
GitHub has Github Secrets, Amazon AWS has Parameter
Store and Secrets Manager.


Configuring Ember-CLI
In the previous section, we have seen how we can configure
the Ember application to handle things in the run time. Next,
we will see how we can configure Ember-CLI to set up the
parameters to be called when running the server. There are
two ways to handle the Ember-CLI parameters:
Pass the parameters when running the ember serve
command
Configure the parameters through the .ember-cli file in
the project with the required parameters
Configuring the .ember-cli file is preferred because it is a one-
time setup and you can just call ember serve or ember s
after that and the parameters are implicitly applied. Even
when the project is worked on by multiple developers, this
becomes useful as every one might not pass all the
parameters when running manually and this might lead to
misconfiguration. Let us look at some of the parameters that
can be configured through the .ember-cli file:
port - The default port Ember uses is 4200. But in certain
cases, we might want to use a different port if 4200 has
been used by some other process.


liveReload - Live Reload is the process of refreshing the
browser page automatically whenever a file in the
project has changed. This flag is by default true and you
can set it to false and the changes are reflected only
when you manually refresh the browser.


isTypeScriptProject - Typescript is disabled by default in a
new Ember project. When this flag is set to true, any
blueprint generator we use in the project will create the
objects compatible with TypeScript syntax.


disableAnalytics - If you wish to send your local Ember
server stats and information to the Ember community,
you can set this flag to true. The data that is sent from
your server is completely anonymous and used by the
community to keep track of server-level errors, and so
on.


proxy - When running the Ember server from your local
setup, there might be cases where a direct request from
the browser might cause Content Security Policy
(CSP) or Cross-Origin Request Sharing (CORS)
errors. To overcome these errors, we can specify the
proxy with a URL. Whatever requests are sent to the
Ember server that cannot be handled by the server will
be sent to this Proxy URL. By doing so, the browser has
the illusion of sending the request to the same domain
and not a different domain.


A sample of the .ember-cli file with these values filled will
look like this:
{
“port”: 4201,
“liveReload”: true,
“isTypeScriptProject”: true,
“disableAnalytics”: false,
“proxy”: “http://localhost:8000”
}
Prototype Extensions
We have seen in the previous chapter how Ember keeps
track of (observes) changes to tracked variables to update
dependent variables or update the values displayed on the
screen. This works by default for simple variable types like
string, number, or boolean. When it comes to Array
elements, the tracking does not work as it is. In order to
observe changes done to an Array object, Ember has defined
its own versions of the Array object that are observer-
friendly.


Ember defines two Array-type objects and recommends
using these for storing and manipulating a list of elements:
EmberArray
MutableArray
A
MutableArray
is
an
Array
whose
values
can
be
changed/updated once they are created. An Immutable
Array’s values cannot be changed after creation. Any change
you make like adding, removing, or updating elements
cannot be done on that object, but only on a copy of that
object.


Advantages of Immutability
By default, objects in JavaScript are mutable. But there are
some advantages when an Array-like object is made
immutable:
When passing the Array to another function, we cannot
be sure that the operations done inside the function do
not affect the original array object sent to the function.


We might want to ensure the changes are done to a
copy of the Array and not disturb the original Array.


Immutability achieves this purpose.


It is easier to track changes to an object when the value
does not change unless we manually reassign the value
using the same variable name.


When working with asynchronous programs and multi-
threaded processes, mutability can lead to a lot of
problems when the value of the object is somehow
altered and it can easily lead to data corruption in the
object.


Disadvantages of Immutability
Immutability also has the following disadvantages:
This approach uses more memory as a new object is
created every time a change is made to an Array.


From an efficiency point of view, it is faster to update an
existing object rather than create new objects.


Making an Array immutable
As mentioned earlier, Arrays in JavaScript are mutable by
default. But there are ways to make an Array immutable.


Here is an example:
let a = [1, 2, 3];
a.push(4); // Works without error as the array is immutable.


Object.freeze(a);
a.push(5); // Throws an error, as a is immutable.


// In order to modify the array, we need to copy it into a new
// object.


let b = a.map(function(item) {
return item;
});
b.push(5); // Works as Array b is mutable
Disabling Prototype Extensions
Utilizing Ember extensions prevents us from writing a lot of
boilerplate code for handling basic scenarios like listening for
changes to an Array and updating dependent variables or
rerendering the screen, and so on. Even though Ember
recommends using these prototype extensions fully in our
applications, in some cases, when the Ember Application has
to be embedded inside other environments or applications,
or author third-party JavaScript that might use an Ember
addon in places beyond our control. In such cases, we might
have to ensure that the application does not use these
prototype extensions, since they may not be supported by
the end environments. It will lead the application to break
due to conflicting libraries or Array extensions.


You can disable the extensions by passing flags through the
EmberENV section of our config/environment.js file:
const ENV = {
EmberENV: {
EXTEND_PROTOTYPES: false
}
}
Ember also allows you to specifically disable only one
particular extension instead of disabling all of them together.


Here is an example:
const ENV = {
EmberENV: {
EXTEND_PROTOTYPES: {
Array: false
}
}
}
Alternatives to Prototype Extensions
When we disable these extensions in the environment, we
will need to handle some cases if we want our data to be
consistent. For example, using native JavaScript Arrays, we
might display them on screen using a {{#each}} helper.


However, any change made to the Array will not reflect on
the template/screen, as Ember observers do not trigger on
changes to a native Array.


For these cases, Ember provides a method that sets up the
required interfaces to listen for changes in an Array. It is
called Ember.A and can be used with any native Array as
follows:
import {A} from ‘@ember/array’;
let myArray = [‘A’, ‘B’, ‘C’];
myArray.pushObject(‘D’); // Does not trigger any re render
A(myArray);
// The below line triggers re render as myArray is passed
through
// Ember.A()
myArray.pushObject(‘E’)
Handling Deprecations
When new versions of Ember are released, there are always
older functions that are marked for removal from the Ember
source. These functionalities/APIs are deprecated before
they are actually removed from the code. Deprecation
means that the functionality is still present in the code, but
usage of that functionality will generate warnings in your
console.


This way, we can keep track of items that we are going to
have to change when we are going to upgrade to the next
version, without the application being affected in the current
state. When the application gets older and larger, these
warnings get piled up and become hard to manage. The
warnings can become large enough to flood your console
and overshadow useful log messages that you need in the
console. Ember provides a clean and simple way to handle
these deprecations and clean them up one by one.


Filtering Deprecations
Whenever new versions of Ember are released, it is better to
upgrade the version of your project along with other
dependencies. When you wish to upgrade your Ember
version, you need to make sure you are not using any
APIs/functionalities that are removed in the new version.


Over the years, the number of deprecations can increase and
it will be an easy option to filter out deprecations that are
removed only in the next version you are upgrading to.


Fortunately, Ember provides handlers to decide which
deprecations have to be notified and which to ignore. You
can add this handler anywhere in the application and it is
registered during runtime to override the default deprecation
handling behavior. Here is an example of how the handler
works:
import { registerDeprecationHandler } from ‘@ember/debug’;
export function initialize() {
registerDeprecationHandler((message, options, next) => {
if (options && options.until && options.until !== ‘5.3.0’) {
return;
} else {
next(message, options);
}
});
}
export default { initialize };
Here, we change the if condition with the version that we are
going to upgrade next to. So if we upgrade to 5.5.0, we
change the version from 5.3.0 to 5.5.0 and only deprecations
that are removed from the code in Ember version 5.5.0 will
be logged in the console.


Deprecation Workflow
By adding the previously mentioned deprecation handler, we
can filter out deprecations that need not be handled
immediately and concentrate on items that have to be
handled before upgrading to the next version. Even after
that, there can be a lot of deprecations, or deprecation
warnings, that are triggered only when a certain scenario is
met, or when a certain UI flow is triggered. How will we be
sure that we have found and updated all the deprecations
and the code is clean enough to move to the next version?
This is where the addon ember-cli-deprecation-workflow
comes into place.


The addon once installed, will keep track of all the
deprecations encountered from the time the server was
started, to the time we generate a dump of the same. You
can
even
run
your
entire
test
suite
by
visiting
http://localhost:4200/tests
and
it
will
ensure
all
deprecations in the code covered by the test suite are
tracked. Once we have gone through the test suite and done
manual testing for places not covered by the test cases, we
are ready to generate the dump of all deprecations. You can
go to your browser console and run the following command:
deprecationWorkflow.flushDeprecations();
The JavaScript code printed as a response to this command
can be copied and pasted into a new file named deprecation-
workflow.js in the project root folder. The response is a
JavaScript code and it will look something like this:
window.deprecationWorkflow = window.deprecationWorkflow || {};
window.deprecationWorkflow.config = {
workflow: [
{ handler: “silence”, matchMessage:
“Ember.Handlebars.registerHelper is deprecated, please
refactor to Ember.Helper.helper.” },
]
The workflow list will contain one entry for every unique
deprecation message collected during the test period. Also
note the handler: “silence”: Once saved in the deprecation-
workflow.js
file,
this
denotes
that
the
corresponding
deprecation message will not be displayed and will be
suppressed.


When we decide to make changes to the code to remove all
usage of the particular deprecated functionality, we will
change the handler value to throw instead of silence. Once
updated, it will throw an error in the browser whenever that
deprecation is encountered. Even after we remove all
occurrences, it is better to leave the handler value as it is, so
that during the runtime of the application, if we encounter
this anywhere else, we will get to know immediately. Going
through all the items in the workflow list and handling each
of them will make your application “deprecation-free”.


URL Types
We have seen earlier that when we move from one route to
another, the URL in the browser gets updated to reference
the new route. There are different options for configuring
how Ember has to handle URLs when transitioning from one
route to another. It is configured using the locationType
setting present in your config/environment.js file. If you open
the file you can see that the setting is set to history. Here
are the options that you can set for locationType:
history - This is the default option that uses the History
API of the browser to track transitions. Using this
method, the route URL is appended to the domain part.


So the URL for our client detail route is /clients/1.


hash - This was a method used by single-page
applications to update URLs without triggering a page
refresh. This method keeps the URL part of the location
constant and updates the route based on the anchor
tag (#). So, for example, the URL for the client detail
route will be http://localhost:4200/#/clients/1. This
method uses the hashchange event present in the browser
to update the anchor part of the URL. Only the part after
the # changes when transitioning between routes.


auto - Some older browsers do not support the History
API. In those cases, we might want to use the hash
method in those browsers, but use the History API when
it is available. auto option takes care of that and switches
between the two modes based on the capability of the
browser.


none - In cases where we are embedding our application
inside another website, we do not want our Ember
application to interact with or update the browser URL at
all. For such applications, you can set the locationType to
none and then we need not worry about the browser URL
being updated by the Ember application.


Embedded Applications
An Ember application is designed to function independently.


Even then, there can be cases where we want an Ember
application to be embedded into another HTML page and be
served from the same domain as the parent page (to prevent
issues arising due to embedding a URL from a different
domain through an iframe).


Root Element
When embedding an Ember application inside another page,
the base page could use plain JavaScript or any other
frontend framework for its application. So it is better to
restrict all of Ember’s activities to a specific root element
that we assign to our application. By default, Ember
generates the template as HTML and appends it to the body
tag of the HTML page. We can override that using the
rootElement property in the app/app.js file:
export default class App extends Application {
…
rootElement: ‘#ember-application’
}
The value of the rootElement property can be any valid jQuery
selector that we have seen in the preceding chapters.


Root URL
As mentioned earlier, we might have cases where multiple
applications are served through the same domain. It is also a
common practice to serve both frontend and backend
applications from the same domain to prevent CORS issues.


In those cases, we will have to specify a sub-URL for Ember
application to identify that all the routes will be prefixed with
a particular URL path. This can be set in the ENV object of the
config/environment.js file:
let ENV = {
…
rootURL: ‘/apps/ember/’,
}
Once set, all URLs accessed from Ember will need to add the
prefix /apps/ember/. For example, the client detail route will
now
look
like
this:
http://localhost:4200/apps/ember/clients/1. If you look
at how this works, you can see these values being passed to
the app/router.js file for the router to parse and update URLs
in the browser. You can see the following lines in the
app/router.js file:
import config from ‘my-ember-project/config/environment’;
export default class Router extends EmberRouter {
location = config.locationType;
rootURL = config.rootURL;
}
Feature Flags
When new features are built into the Ember framework,
before the code is merged into the main branch of the Ember
repository, the entire code related to the feature is placed
inside if-else blocks. It can be conditionally enabled in your
project based on the config. It is done so because of two
reasons:
Any issues with newly developed features should not
affect planned releases or cause issues in any existing
projects.


The code should be tested by the Ember community
before they deem it ready for production use.


Life-cycle of an Ember feature
A freshly merged feature is available only by enabling the
feature from your config file. At the start of a release cycle,
the Ember community tests each feature and features that
pass the testing are enabled and pushed to the beta stage,
and become part of the next stable release of Ember.


Features that receive negative feedback are disabled until
the issues present are resolved.


Ember has an inbuilt package named canary-features that
exports a list of flagged features in a release, and its status.


A newly built feature can be of the following statuses:
true - The feature is present and enabled in this build.


null - The feature is present, but disabled by default. We
can enable it from the config file.


false - The feature is completely disabled. It cannot be
enabled in this build.


The features with the null status are optional and can be
enabled from the configuration file. Any developer creating a
feature in Ember will add a flag for that feature in a file
called FEATURES.md in the repository. The entry will contain the
flag associated with the feature and a description of what
the feature does.


Enabling features in runtime
The features with the status as null (present but not
enabled)
can
be
enabled
at
runtime
through
the
config/environment.js file. You can see that the file contains a
section called FEATURES inside the EmberENV section of the ENV
object. Here is how you can enable a feature:
const ENV = {
EmberENV: {
FEATURES: {
EMBER_NATIVE_DECORATOR_SUPPORT: true
},
},
}
This can be used to enable a specific feature in our project. If
you want to enable all the canary features instead of
specifying them one by one, you can use the catch-all flag as
follows:
const ENV = {
EmberENV: {
ENABLE_OPTIONAL_FEATURES: true
},
}
Optional Features
Ember has a set of “optional features” which can be
enabled and disabled at will. It is powered by an addon
named @ember/optional-features. This addon is automatically
installed when the project is created. You can see the list of
optional features shipped by default using the following
command:
ember feature:list
This will list all the optional features available by default. The
output will look as illustrated in Figure 6.2. Let us look at a
couple of these features and what they do.


application-template-wrapper
-
This
feature
is
enabled by default. If enabled, it will add a wrapper
around the rendered content of the page with the class
.ember-view. This can be used to target the elements in
the page by using the class name.


jquery-integration - Even though Ember has a rich set
of features that can manipulate the DOM and its
contents, sometimes jQuery is required to manipulate
elements directly from inside a component. This can be
achieved by enabling this optional feature and then
installing an addon - @ember/jquery. Once done, you will
be able to access jQuery from any of the files using
this.$().


Figure 6.1: Ember optional features
Figure 6.2 shows the list of available optional features. You
can enable any feature by using the following command:
ember feature:enable jquery-integration
The command will result in an output as follows:
Figure 6.2: Enabling an optional feature
You can now see from the message that Ember has created a
new file called config/optional-features.json which tracks the
status of each optional feature. The file will look like this:
{
“application-template-wrapper”: true,
“default-async-observers”: true,
“jquery-integration”: true,
}
It shows that we have all the optional features enabled. To
disable a feature, you can use the disable command:
ember feature:disable jquery-integration
Once disabled, you can confirm that by opening the
config/optional-features.json and making sure the jquery-
integration is set to false. These are a broad overview of the
features and functionalities provided by the Ember CLI.


Build Targets
An advantage of a web application is that it can be accessed
by the end users from the comfort of their browsers without
any additional configurations or downloads. However, when
it comes to frameworks like Ember, they are built and
compressed before they are used in the browser. As we
know, Ember code is transformed into JavaScript code that
can be read from the browser. Ember, by default, uses
Babel.js, a transcompiler that converts modern JavaScript
code into code that can be parsed by the browser.


As technology advances and browsers are upgraded, users
move over to new browsers, with support for JavaScript code
that can be compressed further, thus reducing the size of our
application that is loaded in the browser. Depending on your
user base, Ember allows you to specify the browser versions
that your application is supposed to support. With this
specification, Ember can decide how efficiently it can
compress/translate the JavaScript code.


Inside the config folder, you can see a targets.js file, with the
following code:
const browsers = [
‘last 1 Chrome versions’,
‘last 1 Firefox versions’,
‘last 1 Safari versions’,
];
module.exports = {
browsers,
};
You can see that our application supports the latest versions
of the most widely known browsers like Chrome, Firefox, and
Safari. Specifying it in a relative manner and not the
absolute version will help the application keep updated
based on new releases from both the browser side and from
Ember releases.


Robots.txt
Have you ever wondered how search engines like Google
fetch information about so many websites and give it to you
within milliseconds of searching? These search engines have
automated bots called Web Crawlers that explore the
internet. The goal of such a bot would be to learn about any
and all web pages in the world wide web, download and
index them so that the search engine can filter and show
them to people who search with the relevant keywords.


We would usually want our web application/website to show
up on the first page of the search results for keywords
related to our business. But, we will need some pages of our
website to be hidden from search engines so that they are
private only for users you want to share it with. Every search
engine bot that tries to query your website will first look for a
/robots.txt URL on the website, which tells the bot which
pages can be indexed and which cannot. You can go to
http://localhost:4200/robots.txt
to
see
the
default
configuration in Ember, and the same file inside the
public/robots.txt file in the repository.


The robots.txt file will have the following content by default:
# http://www.robotstxt.org
User-agent: *
Disallow:
The robots.txt syntax contains the following syntax:
User-agent: User-agent is used to specify the specific bot
this configuration is applied to. If you specify a *, it
means it applies to all the bots (search engines).


Disallow: The Disallow keyword is used to prevent a
specific pattern of URLs from being excluded when
indexing.


Allow: Allow keyword specifies a specific URL pattern to
be indexed.


Here are a few scenarios and how you can configure your
robots.txt for those cases:
Allow all URLs to be indexed - The default
configuration of robots.txt is to allow indexing of all
URLs. You can see the User-agent key is set to * and
Disallow is empty. This indicates that none of the URLs
are to be disallowed.


Allow specific URLs - Some applications where you
have both public-facing pages and private pages that
are not required to be indexed/appear in search results.


The robots.txt will be set to the following content for
such a case:
User-agent: *
Allow: /public/
Disallow: /
We can see that only URLs that start with /public are
allowed to be indexed and the rest are disallowed. The
same can be reversed to allow only a specific pattern of
URLs to be prevented from indexing.


User-agent: *
Disallow: /private-path/
Allow: /
User agent based - For certain cases, for example,
based on the region/country that your app is being
deployed to, you might want to disable indexing in
certain search engines and enable the same in other
engines. Robots.txt allows you to specify individual
configurations for each search engine bot. A list of
popular bots is displayed on the robots.txt website here -
http://www.robotstxt.org/db.html. Here is how you can
configure robots.txt for specific agents:
User-agent: Googlebot
Disallow: /
User-agent: *
Allow: /
Here we specify a separate configuration just for Googlebot,
disabling it to index any URL. Every other bot can index all
the URLs. This can be extended to write individual
configurations for multiple bots.


When
configuring
your
robots.txt
file,
you
need
to
understand that when multiple blocks are configured (each
block is separated by the User-agent keyword), bots take the
first block that matches the condition and fetch their
instructions from that. For example, if we have the Disallow
block for Googlebot after the User-agent: * block, bots will not
consider the specific Googlebot block, as their condition
matches the first block itself.


Configuring robots.txt for each
environment
Usually, the robots.txt file for each environment will be
different. You will not want bots to index your staging
environments, but you will want them to index all URLs in
your production environment. So the robots.txt will have to
be defined separately for the different environments based
on your deployment setups. You can name the files based on
the environment names, like robots-prod.txt, robots.txt, and
so on. And we can configure the ember-cli-build.js file to
include the correct file based on the environment as follows:
const EmberApp = require(‘ember-cli/lib/broccoli/ember-app’);
const stew = require(‘broccoli-stew’);
module.exports = function (defaults) {
const app = new EmberApp(defaults, {
sassOptions: {
extension: ‘scss’,
},
‘ember-bootstrap’: {
bootstrapVersion: 5,
importBootstrapCSS: false,
},
});
var appTree = app.toTree();
var env = EmberApp.env();
if (env === ‘production’) {
appTree = stew.rm(appTree, ‘robots.txt’);
appTree = stew.rename(appTree, ‘robots-prod.txt’,
‘robots.txt’);
} else {
appTree = stew.rm(appTree, ‘robots-prod.txt’);
}
return appTree;
};
We are using a package named broccoli-stew to find and
modify the appTree during the build time. With this, we can
define a specific instruction to index only our production
website, and all other hosted environments like staging and
development can be ignored.


Conclusion
In this chapter, we looked at how we can configure the
Ember application for the building and deployment process.


We learned to tweak the Ember settings to modify the way
the application behaves for each environment; the actions
done during the build, and so on. We learnt about the
recommended ways to pass secrets and credentials through
a .env file and why it is a security issue to include these
values inside the repository itself. Then we saw the need for
a .ember-cli file and how it provides a single configuration
system for multiple developers working on a single Ember
project, and not requiring to manually pass the variables
while running the application each time.


Next, we learned about Ember’s additional extensions for
Arrays and how they are used to track changes to Arrays
during the runtime of the application. However, just like any
other feature in Ember, this can also be configured as per
our requirements and we saw how we can disable these
extensions and write alternate code in such cases. We looked
at deprecations and how they can be handled effectively
through Ember addons. We also learned about different ways
the application interacts with the browser URL and what their
differences are. Then we saw how we can embed our Ember
application inside another webpage and the necessary
configuration changes required for it.


We saw how we can optionally enable different features that
are not publicly enabled in the Ember version we are using.


Also, we learned how to specify the list of browsers
supported by our application to allow Ember to generate the
build effectively. Then we looked at robots.txt and how it can
be customized to instruct bots on which pages they can
index and which pages they cannot. In the next chapter, we
will look in detail at the different types of tests you can write
to ensure that your application works as expected and how
you can write tests in Ember effectively.


Points to Remember
Ember provides a wide range of flexibility to configure
how the application runs and builds.


It is not recommended to hard-code credentials in your
application and push them to your version control
system.


You can modify the build process based on the
environment specified when generating the build.


.ember-cli file can be used to define the parameters
passed when running the ember server.


Ember has built-in extensions to default objects like
Arrays for observing changes and updating templates
and dependent variables. They can be disabled in the
runtime.


You can define which browser API (hash or history API)
Ember uses to interact with the browser URL.


Ember applications can be easily embedded into other
web pages with small tweaks.


Ember has a list of optional features which can be
enabled based on our requirements.


We can specify the list of browsers supported by our
Ember application. The list need not be a hard-coded list
of versions, but relative to the latest version.


Multiple Choice Questions
1. Which of the following is not a valid key in the
config/environment.js file?
a. rootURL
b. EmberENV
c. locationType
d. None of the above
2. What file is used to specify the parameters passed to the
ember server?
a. .ember-cli
b. .ember-server
c. .ember-params
d. .ember-config
3. Which of the following is an extension provided by
Ember?
a. Ember.DynamicArray
b. Ember.ImmutableArray
c. Ember.MutableArray
d. Ember.StaticArray
4. What is a valid option for the locationType config in the
environment.js file?
a. history
b. hash
c. auto
d. All of the above
5. What is the keyword used to enable all experimental
flags in the current Ember version?
a. ENABLE_EXPERIMENTAL_FEATURES
b. ENABLE_OPTIONAL_FEATURES
c. ENABLE_PRESENT_FEATURES
d. None of the above
6. Which of the following is not a valid optional feature
shipped by Ember?
a. jquery-integration
b. default-async-observers
c. bootstrap-integration
d. application-template-wrapper
Answers
1. d
2. a
3. c
4. d
5. b
6. c
Questions
1. What are the disadvantages of making an object
immutable?
2. What are the differences between hash and history APIs?
3. How do you handle deprecations that are removed in the
upcoming version?
4. What
are
the
configurations
to
be
updated
for
embedding your Ember application into another web
page?
5. What are experimental features and the different
statuses of these features in a shipped Ember version?
6. What are the optional features shipped in Ember and
how do you enable them?
7. What are the different configurations that can be done
to robots.txt?
8. What is a sitemap?
Key Terms
Environment - Variable used to denote the type of build
we are going to generate.


App Secrets - Sensitive information such as credentials
to APIs our application interacts with.


Deprecation - A functionality or API in the repository
that has been decided to be removed from a future
release of Ember.


Experimental Feature - A feature is considered
experimental when it is released for the first time in an
Ember release. It stays the same manner until the
Ember community deems it fit for production use.


Optional Feature - A feature that is shipped as part of
the Ember release, but not enabled. We can enable the
feature if required by our project.


Web Crawler - A bot (usually part of a search engine)
that finds all content available on the internet,
downloads and indexes them for providing search results
in their engine.


Robots.txt - A file used to define which URLs should be
indexed/excluded by a web crawler thereby defining
which pages should appear in search results.

